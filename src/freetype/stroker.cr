module Freetype
  # FT_Stroker wrapper
  #
  # This component generates stroked outlines of a given vectorial glyph. It
  # also allows you to retrieve the 'outside' and/or the 'inside' borders of
  # the stroke.
  #
  # This can be useful to generate 'bordered' glyph, i.e., glyphs displayed
  # with a coloured (and anti-aliased) border around their shape.
  class Stroker
    getter stroker : LibFreetype::FT_Stroker

    def initialize
      library = Freetype.get_handle
      stroker = Pointer(LibFreetype::FT_Stroker).malloc
      error = LibFreetype.FT_Stroker_New(library, stroker)
      raise Error.new(error) if error > 0
      @stroker = stroker
    end

    # Reset a stroker object's attributes.
    def set(radius, line_cap, line_join, miter_limit)
      LibFreetype.FT_Stroker_Set(@stroker, radius, line_cap, line_join, miter_limit)
    end

    # Reset a stroker object without changing its attributes. You should call
    # this function before beginning a new series of calls to
    # FT_Stroker_BeginSubPath or FT_Stroker_EndSubPath.
    def rewind
      LibFreetype.FT_Stroker_Rewind(@stroker)
    end

    # A convenience function used to parse a whole outline with the
    # stroker. The resulting outline(s) can be retrieved later by functions
    # like FT_Stroker_GetCounts and FT_Stroker_Export.
    #
    # **Note**:
    #
    #   If 'opened' is 0 (the default), the outline is treated as a closed
    #   path, and the stroker generates two distinct 'border' outlines.
    #
    #   If 'opened' is 1, the outline is processed as an open path, and the
    #   stroker generates a single 'stroke' outline.
    #   This function calls 'rewind' automatically.
    def parse_outline(outline, opened = false)
      opened = opened ? 1 : 0
      error = LibFreetype.FT_Stroker_ParseOutline(@stroker, outline, opened)
      raise Error.new(error) if error > 0
    end

    # Start a new sub-path in the stroker.
    #
    # **Note**:
    #
    #   This function is useful when you need to stroke a path that is not
    #   stored as an 'Outline' object.
    def begin_subpath(to, open)
      error = LibFreetype.FT_Stroker_BeginSubpath(@stroker, to, open)
      raise Error.new(error) if error > 0
    end

    # Close the current sub-path in the stroker.
    #
    # **Note**:
    #
    #   You should call this function after 'begin_subpath'. If the subpath
    #   was not 'opened', this function 'draws' a single line segment to the
    #   start position when needed.
    def end_subpath
      error = LibFreetype.FT_Stroker_EndSubpath(@stroker)
      raise Error.new(error) if error > 0
    end

    # 'Draw' a single line segment in the stroker's current sub-path, from
    # the last position.
    #
    # **Note**:
    #
    #   You should call this function between 'begin_subpath' and
    #   'end_subpath'.
    def line_to(to)
      error = LibFreetype.FT_Stroker_LineTo(@stroker, to)
      raise Error.new(error) if error > 0
    end

    # 'Draw' a single quadratic Bezier in the stroker's current sub-path,
    # from the last position.
    #
    # **Note**:
    #
    #   You should call this function between 'begin_subpath' and
    #   'end_subpath'.
    def conic_to(control, to)
      error = LibFreetype.FT_Stroker_ConicTo(@stroker, control, to)
      raise Error.new(error) if error > 0
    end

    # 'Draw' a single quadratic Bezier in the stroker's current sub-path,
    # from the last position.
    #
    # **Note**:
    #
    #   You should call this function between 'begin_subpath' and
    #   'end_subpath'.
    def cubic_to(control1, control2, to)
      error = LibFreetype.FT_Stroker_CubicTo(@stroker, control1, control2, to)
      raise Error.new(error) if error > 0
    end

    # Call this function once you have finished parsing your paths with the
    # stroker. It returns the number of points and contours necessary to
    # export one of the 'border' or 'stroke' outlines generated by the
    # stroker.
    def border_counts(border)
      anum_points = Pointer(LibC::UInt).malloc
      anum_contours = Pointer(LibC::UInt).malloc
      error = LibFreetype.FT_Stroker_CubicTo(@stroker, border, anum_points, anum_contours)
      raise Error.new(error) if error > 0
      {anum_points.value, anum_contours.value}
    end

    # Call this function after 'get_border_counts' to export the
    # corresponding border to your own 'Outline' structure.
    #
    # Note that this function appends the border points and contours to your
    # outline, but does not try to resize its arrays.
    #
    # **Note**:
    #
    #   Always call this function after get_border_counts to get sure that
    #   there is enough room in your 'Outline' object to receive all new
    #   data.
    #
    #   When an outline, or a sub-path, is 'closed', the stroker generates two
    #   independent 'border' outlines, named 'left' and 'right'.
    #
    #   When the outline, or a sub-path, is 'opened', the stroker merges the
    #   'border' outlines with caps. The 'left' border receives all points,
    #   while the 'right' border becomes empty.
    #
    #   Use the function export instead if you want to retrieve all borders
    #   at once.
    def export_border(border, outline)
      LibFreetype.FT_Stroker_ExportBorder(@stroker, border, outline.outline)
    end

    # Call this function once you have finished parsing your paths with the
    # stroker. It returns the number of points and contours necessary to
    # export all points/borders from the stroked outline/path.
    def counts
      anum_points = Pointer(LibC::UInt).malloc
      anum_contours = Pointer(LibC::UInt).malloc
      error = LibFreetype.FT_Stroker_GetCounts(@stroker, anum_points, anum_contours)
      raise Error.new(error) if error > 0
      {anum_points.value, anum_contours.value}
    end

    # Call this function after get_border_counts to export all borders to
    # your own 'Outline' structure.
    #
    # Note that this function appends the border points and contours to your
    # outline, but does not try to resize its arrays.
    def export(outline)
      LibFreetype.FT_Stroker_Export(@stroker, outline.outline)
    end

    def finalize
      LibFreetype.FT_Stroker_Done(@stroker)
    end
  end
end
